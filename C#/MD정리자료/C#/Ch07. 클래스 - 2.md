# Ch07. Class - 2



## 1. 클래스 상속

### 사용되는 용어

	- 부모 클래스 : base, parent, 상위, super
	- 자식 클래스 : deerived, child, 파생, sub 

**상속을 하는 이유 : 클래스를 재사용 및 확장하여 사용할 수 있다. 또한 클래스는 하나의 묶음처럼 관리하기 때문에 프로그램의 유지보수가 용이해진다.**

```C#
class Super
{
    protected int a; // privite 속성을 사용할 경우 자식 클래스에서 사용할 수 없다.
    
    public void Print() {
        console.WriteLine("Super Print()");
    }
}
class Sub:Super
{
    int b;
	public void Print() {
        console.WriteLine("Sub Print() a: {0}, b: {1}", a, b) // 부모 클래스로부터 a를 상속받았기 때문에 사용 가능!
    }
}
    

```



```C#
namespace _081_02_classInheritance
{
    class Super
    {
        protected int a;
        public Super() {
            a = 100;
            Console.WriteLine("  Call Super 생성자 호출");
        }
        ~Super() {
            Console.WriteLine("  Call Super 소멸자 호출");
        }
    }
    class Sub:Super
    {
        public Sub() {
            Console.WriteLine("Call Sub 생성자 호출");
        }
        ~Sub() {
            Console.WriteLine("Call Sub 소멸자 호출");
        }
    }
    class Program
    {
        static void Main(string[] args) {
            //Super super = new Super();
            Sub sub = new Sub();
        }
    }
}
/* 결과 */
  Call Super 생성자 호출
Call Sub 생성자 호출
Call Sub 소멸자 호출
  Call Super 소멸자 호출
      
자식 클래스의 객체를 생성하기 위해서 부모 클래스의 생성자 함수가 호출되고, 자식 클래스의 생성 및 소멸자가 호출된 뒤, 마지막으로 부모 클래스의 소멸자 함수가 실행된다.
```



 - base키워드를 사용하면 부모 클래스에 접근할 수 있다.

    - ```C#
      namespace _081_03_class_base
      {
          class Super
          {
              int num;
              protected string name;
              public Super(int num) {
                  this.num = num;
              }
              public void PrintSuper() {
                  Console.WriteLine("Super  num: {0} ", num);
              }
          }
          class Sub : Super
          {
              string name;
              public Sub(int num, string name):base(num) { // base 키워드를 사용해서 부모 클래스의 num에 접근한다.
                  this.name = name;
              }
              public void PrintSub() {
                  base.name = "Super";
                  base.PrintSuper();
      
                  Console.WriteLine("Super  name: {0}", base.name); //부모 클래스에 저장된 Super가 출력된다.
                  Console.WriteLine("Sub  name: {0}", this.name); //자식 클래스에 저장된 Jack이 출력된다.
              }
          }
          class Program
          {
              static void Main(string[] args) {
                  Sub sub = new Sub(26, "Jack");
                  sub.PrintSub();
              }
          }
      }
      /* 결과 */
      Super  num: 26
      Super  name: Super
      Sub  name: Jack
      ```



<hr>



## 2. IS / AS 키워드



 - is 키워드
   	- 객체의 형식을 검사하여 bool형태를 리턴한다.
- as 키워드
  - 형식을 변환하며, null값을 리턴한다.(예외처리에 사용된다)



```c#
namespace _082_as
{
    class Base
    {
        int num; //기본적으로 private속성을 받기 때문에 자식 클래스에서 사용할 수 없다.

        public void Print() {
            Console.WriteLine("num: {0}", num);
        }
    }
    class AA : Base
    {
        int a;

        public void PrintA() {
            Console.WriteLine("a: {0}", a);
        }
    }

    class BB : Base
    {
        int b;

        public void PrintB() {
            Console.WriteLine("b: {0}", b);
        }
    }

    class Program
    {
        static void Main(string[] args) {
            Base _base = new Base();
            _base.Print();

            Base aa = new AA(); //부모 클래스의 이름으로 자식 클래스를 생성한다(할 수 있다!)
            aa.Print();

            if(aa is BB) { //is키워드를 사용하여 aa가 BB객체인지, AA객체인지 판단할 수 있다.
                Console.WriteLine("aa는 BB의 객체 입니다");
            }
            else if(aa is AA) { 
                Console.WriteLine("aa는 AA의 객체 입니다");
            }

            Base bb = new BB();

            BB copyBB = bb as BB; //강제 형 변환
            if(null != copyBB) {
                Console.WriteLine("------------------------------------");
                Console.WriteLine("copyBB는 BB객체를 형식 변환!!");
                copyBB.PrintB();
            }

            Base copyAA = bb as AA;
            if(null == copyAA) {
                Console.WriteLine("------------------------------------");
                Console.WriteLine("copyAA는 AA객체가 아니므로 null!!");

                copyAA = new AA();
                copyAA.Print();

                AA asAA = copyAA as AA; //강제 형 변환
                asAA.PrintA();
            }
        }
    }
}
/* 결과 */
num: 0
num: 0
aa는 AA의 객체 입니다
------------------------------------
copyBB는 BB객체를 형식 변환!!
b: 0
------------------------------------
copyAA는 AA객체가 아니므로 null!!
num: 0
a: 0
```



<hr>

## 3. 다형성 - Virtual, Override

 - 객체 지향의 핵심

 - 함수의 오버라이딩(즉, 함수를 재정의한다)

 - 반복문으로 객체를 관리할 수 있다.

    - ```C#
      namespace _083_override
      {
          class Super
          {
              protected int num = 10;
      
              public virtual void Print(){
                  Console.WriteLine("num:  {0}", num);
              }
          }
      
          class AA : Super
          {
              public int a = 5;
      
              public override void Print() {
                  base.Print();
                  Console.WriteLine("AA a:  {0}", a);
                  //Print()함수를 base.Print()를 실행한 후, 내가 실행하는 기능(29번쨰줄)을 추가적으로 실행한다.
              }
          }
      
          class BB : Super
          {
              public int b = 3;
              public override void Print() {
                  base.Print();
      
                  Console.WriteLine("BB b:  {0}", b);
              }
          }
      
          class Program
          {
              static void Main(string[] args) {
                  Super super = new Super();
                  super.Print();
      
                  Super aa = new AA();
                  aa.Print();
      
                  Super bb = new BB();
                  bb.Print();
              }
          }
      }
      
      /* 결과 */
      num:  10
      num:  10
      AA a:  5
      num:  10
      BB b:  3
      ```

