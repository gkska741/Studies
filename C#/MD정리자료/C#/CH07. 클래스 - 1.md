# Ch07. 클래스 - 1



- 클래스 개념
  - 클래스는 사용자가 직접 만든 틀
  - 변수와 함수를 하나의 단위로 결합
  - 상속, 다형성, 파생 클래스 클래스의 특수화 메커니즘 등이 있다.

 - ```C#
   public class Point //클래스 이름: Point
   {
       public int x, y; //변수(필드) / 멤버 변수
       
       public Point() //메소드(함수) - 선언된 변수 : x,y를 사용한다. / 멤버 함수
       {
           //이부분에 내용이 들어간다.        
       }
       public Point2() 
       {
           //내용 2
       }
   }
   ```



 - 대표적인 접근 한정자 - 클래스의 멤버에 접근할 수 있는 수준

   	- public : 제한 X
   	- protected : 파생 클래스로만 접근이 제한됨
   	- private : 이 클래스로만 접근이 제한된다.

- new키워드

  - 클래스의 객체를 생성한다.

  - ```C#
    // 클래스명 객체명 = new 생성자
    AA aa = new AA();
    ```

- 생성자, 소멸자

  - 생성자 : 객체를 생성할 때 호출한다. (new 키워드)
    - 클래스 명과 동일하다
    - 리턴형이 없다 - public 클래스 이름(파라미터)
    - 접근한정자는 public이다.
    - 객체 생성시 기본값을 설정할 수 있다.
  - 소멸자 : 객체를 소멸시킬 때 호출한다. (Garbage Collecter에 의해 소멸)
    - 클래스 명과 동일하다
    - 리턴형이 없다.
    - 접근 한정자 X
    - '~'키워드로 구성된다.

 - ```C#
   namespace _077_class
   {
       class AA //AA라는 클래스를 생성한다.
       {
           //멤버 변수..
           int num1 = 4; //기본적으로 private속성을 부여받는다.
           public int num2 = 3, num3 = 5;
   
           //멤버 함수..
           public void Print() {
               Console.WriteLine("aa: {0}, bb: {1}, cc: {2}", num1, num2, num3);
           }
       }
   
       class Program
       {
           static void Main(string[] args) {
               AA aa = new AA(); //반드시 new를 사용해야 새로운 aa객체가 생성된다
               //aa.num2 = 100;
               //aa.num3 = 1000;
               //private속성은 접근이 제한되며, public은 새로 값을 정의할 수 있다.
               aa.Print();
           }
       }
   }
   
   /* 결과 */
   aa: 4, bb: 3, cc: 5
   ```

- this 키워드

  - 객체 자신을 참조하는 키워드

  - 사용처

    - 함수의 파라미터 이름과 멤버 션수 이름이 동일할 떄
    - 클래스 내부에서 멤버 변수를 접근하는 경우

  - ```C#
    namespace _079_this
    {
        class AA
        {
            int a; //private속성
    
            public AA(int a) {
                this.a = a;
            }
    
            public void Print() {
                a = 100;
                this.a = 1000;
                Console.WriteLine("a: {0}", a);
                Console.WriteLine("this.a: {0}", this.a);
            }
        }
    
        class Program
        {
            static void Main(string[] args) {
    
                AA aa = new AA(10);
                aa.Print();
            }
        }
    }
    /* 결과 */
    a: 100
    this.a: 1000
    ```

- static 키워드

  - 클래스 멤버를 객체 생성 없이 사용 가능하다. : new키워드를 사용하지 않아도 된다.

  - 클래스 static 필드(변수) 

  - 클래스 static 메서드(함수)

  - static 메서드 내부에 사용하는 변수는 반드시 static

  - ```C#
    namespace _080_static
    {
        class AA
        { 
            public static int a;
            public static int b;
            public static readonly int c = 200; //상수화된 변수
            //정적 함수는 반드시 정적 변수만 참조 가능..
            public static void Print() {
                Console.WriteLine("a: {0}", a);
                Console.WriteLine("b: {0}", b);
    
                //Console.WriteLine("c: {0}", c); //오류
            }
        }
    
        class BB
        {
            public int a;
            public int b;
    
            public void Print() {
                Console.WriteLine("a: {0}", a);
                Console.WriteLine("b: {0}", b);
            }
        }
    
        class Program
        {
            static void Main(string[] args) {
                AA.a = 10;  //객체 생성 없이 바로 접근..
                AA.b = 100; //객체 생성 없이 바로 접근..
                //AA.c = 200; readonly 속성이기 때문에 변경할 수 없다(오류 발생)
    
                AA.Print(); //객체 생성 없이 바로 접근..
    
                //BB.a //오류..
                //BB.b //오류..
                //BB.Print(); //오류..
    
                BB bb = new BB();
                bb.a = 100;
                bb.b = 200;
    
                bb.Print();
            }
        }
    }
    /* 결과 창 */
    a: 10
    b: 100
    a: 100
    b: 200
    ```

- 클래스의 메서드 활용

  - 클래스가 메서드의 파라미터로서 활용된다.

  - 클래스가 메서드의 리턴형이 된다.

  - ```C#
    static void CopyRefClass(AA aa){
        AA refAA = aa;
        refAA.a = 100;
        refAA.b = 1000;
    }
    ```

  - ```C#
    namespace _081_class_parameter
    {
        class AA //a, b를 생성하는 Class AA를 선언
        {
            public int a;
            public int b;
    
            public AA() {
                a = 0;
                b = 0;
            }
    
            public void Print() {
                Console.WriteLine();
                Console.WriteLine("a: {0}", a);
                Console.WriteLine("b: {0}", b);
            }
        }
    
        class Program
        {
            static void Main(string[] args) {
                AA aa = new AA();
                aa.Print();
    
                CopyRefClass(aa);
                aa.Print();
    
                AA aaa = CopyDeepClass(aa);
                aaa.Print(); //CopyDeepClass함수는 aa객체에 영향을 주지 않는다.
    
                aa.Print();
            }
    		//함수선언 1, AA클래스의 aa객체를 받는다. 참조 후 그대로 변경된다.
            static void CopyRefClass(AA aa) {
                AA refAA = aa;
                refAA.a = 100;
                refAA.b = 10000;
            }
            
            static AA CopyDeepClass(AA aa) {
                AA tempAA = new AA(); //새로운 객체를 생성한다.
    
                tempAA.a = aa.a; //새로운 객체에 aa.a, aa.b, aa.a=0을 대입시킨다.
                tempAA.b = aa.b;
                tempAA.a = 0;
    
                return tempAA;
            }
        }
    }
    
    ```

  - 