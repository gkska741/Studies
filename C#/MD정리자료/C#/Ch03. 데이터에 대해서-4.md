# Ch 03. 데이터란 무엇일까 - 기본데이터3





## 형 변환

 - 데이터의 형식을 변경
    - 정수와 실수 사이의 변환
    - 문자열과 기본 데이터형 간의 변환
       - 큰 데이터를 작은 데이터 형에 넣을 때는 데이터의 왜곡이 생길 수 있기 때문에 주의를 요한다.
- 캐스트 연산자: '( )'
- ToString(), Parse(), Convert.~



```C#
namespace _024_Data_cast
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 100;
            double dNum = (double)num;
            Console.WriteLine("num: {0},  dNum: {1}", num, dNum);

            double dNum2 = 12345678912;
            int num2 = (int)dNum2; //큰데이터형을 작은 데이로 변경시 주의!!!, 캐스트 연산자를 쓰지 않으면 데이터 조작이 되지 않아서 오류 발생
            Console.WriteLine("dNum2: {0},  num2: {1}", dNum2, num2);
        }
    }
}
/* 결과 창 */
num: 100,  dNum: 100
dNum2: 12345678912,  num2: -2147483648
```



#### .Parse 메서드는 .Parse 앞에 붙는 형태로 Parse 메서드 안의 인자를 형변환해주는 의미로 이해하면 된다.

```C#
namespace _026_Data_Parse
{
    class Program
    {
        static void Main(string[] args)
        {
            string strA = "100";
            string strB = "3.141593";
            string strC = "3.1415926535897932384626433832";

            int parseA = int.Parse(strA);
            float parseB = float.Parse(strB);
            decimal parseC = decimal.Parse(strC);

            Console.WriteLine("int.Parse: {0}", parseA);
            Console.WriteLine("float.Parse: {0}", parseB);
            Console.WriteLine("decimal.Parse: {0}", parseC);
        }
    }
}
/* 결과 창 */
int.Parse: 100
float.Parse: 3.141593
decimal.Parse: 3.1415926535897932384626433832
```

##### 

#### Convert 메서드는 Parse와 동일한 기능을 하며, Convert.To자료형(바꾸고싶은자료명) 형태로 작성한다.

```C#
namespace _027_Data_Convert
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 100;
            float b = 3.141593f;
            decimal c = 3.1415926535897932384626433832m;

            string strA = a.ToString();
            string strB = b.ToString();
            string strC = c.ToString();

            Console.WriteLine("a.ToString(): {0}", strA);
            Console.WriteLine("b.ToString(): {0}", strB);
            Console.WriteLine("c.ToString(): {0}", strC);
            Console.WriteLine();

            int parseA = int.Parse(strA);
            float parseB = float.Parse(strB);
            decimal parseC = decimal.Parse(strC);

            Console.WriteLine("int.Parse: {0}", parseA);
            Console.WriteLine("float.Parse: {0}", parseB);
            Console.WriteLine("decimal.Parse: {0}", parseC);
            Console.WriteLine();

            int convertA = Convert.ToInt32(strA);
            float convertB = Convert.ToSingle(strB);
            decimal convertC = Convert.ToDecimal(strC);

            Console.WriteLine("Convert.ToInt32(strA): {0}", convertA);
            Console.WriteLine("Convert.ToSingle(strB): {0}", convertB);
            Console.WriteLine("Convert.ToDecimal(strC): {0}", convertC);
        }
    }
}
```

#### 게임 개발에 있어서 대부분의 데이터는 서버와 통신하는 과정에서 문자열 형태로 주고받기 때문에, 위의 방법을 적절히 사용해서 문자형을 숫자형으로, 또는 적절한 형태로 계속해서 변환하며 사용해야 한다.

## Reference

 - 값형식(value)
    - 모든 수치행태, char, bool, enum...
    - 두개의 변수가 서로 영향을 주지 않음 - 주소가 다르기 때문에!
    - 주소 상에서 새로운 공간에 해당 변수명을 저장한 후, 기존 변수의 주소를 참조하여 새로운 변수가 가지는 주소에 해당하는 공간에 기존 변수의 값을 저장
- 참조형(Refernce)
  - 배열, String, Class, Interface 등 iterable한 값들
  - 두개의 변수가 서로 영향을 준다
  - 그 이유는 값을 저장하는 것이 아닌 주소를 참조하기 때문이다.

```C#
namespace _028_Data_Reference
{
    class Program
    {
        static void Main(string[] args)
        {
            int num = 100;
            int refNum = num;
            refNum = 1000;

            Console.WriteLine("refStr: {0}    ReferenceEquals: {1}", num, Object.ReferenceEquals(num, refNum));

            int[] arrNum = { 100, 200 };
            int[] refArrNum = arrNum; // 여기서 주소를 참조하기 때문에 refArrnum의 값과 arrNum이 서로 같은 값으로 취급된다.
            refArrNum[0] = 1000;

            Console.WriteLine("refStr: {0}   ReferenceEquals: {1}", arrNum[0], Object.ReferenceEquals(refArrNum, arrNum));
        }
    }
}
/* 결과 창 */
refStr: 100    ReferenceEquals: False
refStr: 1000   ReferenceEquals: True
```



## Boxing과 Unboxing



![](사진자료/Boxing_UnBoxing.PNG)

#### heap영역은 오래 지속되기 때문에 계속해서 적체되면 프로그램이 Bulky해진다는 단점이 생긴다. 

#### object o = i;를 사용하면 i값이 boxing 과정에 의해서 heap에 필요없는 데이터가 저장되어 프로그램의 성능 저하가 일어난다.

#### Boxing과 Unboxing이 자주 일어날수록 퍼포먼스의 저하가 일어난다. 최소화할수록 좋다!

```C#
namespace _029_Data_boxing
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 123;
            object o = i;   //boxing
            int j = (int)o; //unboxing
            i = 456;

            Console.WriteLine("i: {0},  o: {1},  j: {2}", i, o, j);
            Console.WriteLine("ReferenceEquals: {0}", Object.ReferenceEquals(i, o));
        }
    }
}
/* 결과창 */
i: 456,  o: 123,  j: 123
ReferenceEquals: False
```



## Console.ReadLine()

	- 한 번에 한 줄씩 문자열로 입력받는다.

```C#
namespace _030_ReadLine
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.Write("정수를 입력하세요?");
            string inputNum = Console.ReadLine();
            int num = int.Parse(inputNum);

            Console.WriteLine("입력한 수는: " + num);
        }
    }
}
/* 결과 창 */
정수를 입력하세요?35     (35는 직접입력한 값)
입력한 수는: 35
계속하려면 아무 키나 누르십시오 . . .
```

#### WriteLine을 쓸 경우 문자열의 마지막에 개행문자가 포함되며, Write의경우는 문자열 뒤에 바로 입력값을 넣을 수 있다.

