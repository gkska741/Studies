# Ch 03. 데이터란 무엇일까 - 기본데이터2



## Object

	- 객체 데이터 형태
	- 어떤 데이터 형이든 모두 처리 가능하다.
	- 클래스에 상속이 적용.



#### 데이터마다 유형이 다르고, 메모리 할당량이 다르기 때문에 최적화의 관점에서 올바른 데이터 형태를 적용시키는게 중요하다.

``` C#
namespace _018_Data_object
{
    class Program
    {
        static void Main(string[] args)
        {
            object a = 100;
            object b = 3.1415926535897932384626433832f;
            object c = 3.1415926535897932384626433832m;
            object d = 'H';
            object e = 'i';
            object f = "World!!";
            object g = false;

            Console.WriteLine("a: {0}", a);
            Console.WriteLine("b: {0}", b);
            Console.WriteLine("c: {0}", c);
            Console.WriteLine("{0}{1} {2}", d, e, f);
            Console.WriteLine("g: {0}", g);
        }
    }
}    
/* 결과 창 */
a: 100
b: 3.141593
c: 3.1415926535897932384626433832
Hi World!!
g: False
```



## enum(이넘)

	- **열거형** 데이터 형태
	- enum 식별자(이름)
	- 코드의 가독성을 높여주는 좋은 데이터 형태. 

``` C#
namespace _020_Data_enum2
{
    enum CHAR_STATE
    {
        IDLE, // 0
        WALK, // 1
        RUN,  // 2
        DIE,  // 3
    }

    enum CLICK_STATE
    {
        NONE, 0
        CLICK = 100, // 100
        DOUBLE_CLICK = 200, // 200
        UP, // 201
    }

    class Program
    {
        static void Main(string[] args)
        {
            CHAR_STATE charState = CHAR_STATE.IDLE;
            Console.WriteLine("캐릴터 상태: {0}  {1}", charState, (int)charState);

            charState = CHAR_STATE.RUN;
            Console.WriteLine("캐릴터 상태: {0}   {1}", charState, (int)charState);

            charState = CHAR_STATE.DIE;
            Console.WriteLine("캐릴터 상태: {0}   {1}", charState, (int)charState);

            Console.WriteLine("CLICK_STATE: {0}   {1}", CLICK_STATE.NONE, (int)CLICK_STATE.NONE);
            Console.WriteLine("CLICK_STATE: {0}   {1}", CLICK_STATE.CLICK, (int)CLICK_STATE.CLICK);
            Console.WriteLine("CLICK_STATE: {0}   {1}", CLICK_STATE.DOUBLE_CLICK, (int)CLICK_STATE.DOUBLE_CLICK);
            Console.WriteLine("CLICK_STATE: {0}   {1}", CLICK_STATE.UP, (int)CLICK_STATE.UP);
        }
    }
}

/* 결과 창 */
캐릴터 상태: IDLE  0
캐릴터 상태: RUN   2
캐릴터 상태: DIE   3
CLICK_STATE: NONE   0
CLICK_STATE: CLICK   100
CLICK_STATE: DOUBLE_CLICK   200
CLICK_STATE: UP   201
```

#### Python에 비교하자면,  List와 비슷하게 위에서부터 차례대로 0~N-1까지의 번호가 부여되어 반복문이나 조건문으로 사용할 수 있다.

#### 차이점은 위의 CLICK = 100 같은 경우에는 100이라는 숫자가 저장된다.(특정 값을 넣을 수 있다) 숫자가 지정되지 않은 값은 그 전의 Index값에 +1한 값이다. 즉 그 자체로 문자열을 저장할 수 있으며, 그 문자열이 지정하는 어떤 숫자형을 직접 지정할 수 있다. 지정하지 않으면 0부터 순차적으로 1씩 증가하는 형태이다.



## Nullable형식

 - 기존 데이터형의 값 + null값 저장가능
 - 사용법 : 데이터 자료형? 식별자
 - ex) int? num = 100;
 - HasValue, Value - 예약함수를 사용할 수 있다.



``` C#
namespace _021_Data_nullable
{
    class Program
    {
        static void Main(string[] args)
        {
            double? a = 3.14;
            char? b = 'a';

            int num = 10;
            int? c = num;

            bool? isFlag = null;

            Console.WriteLine("a: {0}", a);
            Console.WriteLine("b: {0}", b);
            Console.WriteLine("c: {0}", c);

            Console.WriteLine("isFlag: {0}", isFlag);
            Console.WriteLine("isFlag HasValue: {0}", isFlag.HasValue);

            if (isFlag.HasValue) //값을 참조하려면 반드시 null인지 체크..
                Console.WriteLine("isFlag HasValue: {0}", isFlag.Value);
        }
    }
}
/* 결과 창 */
a: 3.14
b: a
c: 10
isFlag:
isFlag HasValue: False
```

#### 코드로 확인해보니 기본데이터에 추가적으로 null값을 할당할 수 있다. 즉 초기화의 목적으로 사용할 수 있을 듯 하다. 또한 .Hasvalue로 null값인지 아닌지(bool 형태), 그리고 .Value로 그 값이 null값이 아닐 경우 참조할 수 있다. null값이면 Value값이 존재하지 않기 때문에 오류가 발생한다.



